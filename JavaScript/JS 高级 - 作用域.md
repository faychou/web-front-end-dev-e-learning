# JS 作用域
简单理解就是存储并查找变量的规则。

## 编译原理
在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编 译”。

### 分词/词法分析(Tokenizing/Lexing) 
这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代 码块被称为词法单元(token)。

### 解析/语法分析(Parsing) 
这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。

### 代码生成将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息 息相关。

对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时 间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法(比如 JIT，可以延 迟编译甚至实施重编译)来保证性能最佳。
简单地说，任何 JavaScript 代码片段在执行前都要进行编译(通常就在执行前)。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。

## 理解执行环境和上下文
函数调用都有与之相关的作用域和上下文。从根本上说，作用域是基于函数(function-based)而上下文是基于对象(object-based)。换句话说，作用域是和每次函数调用时变量的访问有关，并且每次调用都是独立的。上下文总是关键字 this 的值，是调用当前可执行代码的对象的引用。

执行上下文分有 global、function、eval，一个函数可以产生无数个执行上下文，一系列的执行上下文从逻辑上形成了 执行上下文栈，栈底总是全局上下文，栈顶是当前（活动的）执行上下文。

执行上下文三属性：this 指针，变量对象（数据作用域），作用域链

## 函数声明提升和变量声明提升
### 编译过程
以执行一段 function 代码为例，来了解 js 编译器执行代码的过程：

* 第一步：创建可执行上下文（以下简称为 EC），压入当前的 EC 栈中。EC 中包括了以下信息：词法环境（=环境记录项（保存变量、函数声明和形参）+ 外部词法环境（function 的[[scope]]属性，作用域链的本质））this 的指针变量环境（与环境记录项的值相同，但不再发生变动。）

* 第二步：收集函数声明、变量声明和形参，保存在环境记录项内。这个收集的过程，就是一般所谓的声明提升现象的本质。如果发现了重复的标识符，则优先级为函数声明 、形参 、变量声明（优先级低的会被无视）。

* 第三步：开始执行代码，环境记录项内没有的标识符会根据作用域链查找标识符对应的值，环境记录项亦有可能因赋值语句而被修改。

* 第四步：函数执行完毕，EC 栈被弹出、销毁。

### 结论
所以无论作用域中的声明出现在什么地方，都将在代码本身被执行前把所有的声明(变量和函数)移动到各自作用域的最顶端，这个过程被称为提升。 

> 注意：多个不重复声明的代码中，函数会首先被提升，然后才是变量。

## 作用域
### 函数作用域
属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

``` js
function foo () {
  //
}
```

### 块级作用域
在 ES6 之前，JS 中是不存在块级作用域的，具体如下示例：

``` js
for (var i = 0; i < 10; i++) {
  //console.log( i );
}
console.log( 'for 外部的 i 值：' + i );
```

我们发现 for 循环外输出了 i 值，说明该变量可以在 for 循环外使用，同样在 if 、while 等中效果一样的。

而为了解决块级作用域的问题，ES6 中提供了 let、const 的方法来声明变量。

``` js
for (let i = 0; i < 10; i++) {
  //console.log( i );
}
console.log( 'for 外部的 i 值：' + i );
```
此时输出的 i 值就是 undefined 。

### 作用域嵌套
在当前作用域中无法找到某个变量的时候，引擎就会在外层的嵌套作用域中继续查找，直到找到该变量，或抵达最外层的作用域。
