# 结构优化
## defer 和 async
defer 和async 属性 提供给开发者一个方式来告诉浏览器哪些脚本是需要异步加载的。

这两个属性都告诉浏览器，它可以 “在后台” 加载脚本的同时继续解析 HTML，并在脚本加载完之后再执行。这样，脚本下载就不会阻塞 DOM 构建和页面渲染了。结果就是，用户可以在所有的脚本加载完成之前就能看到页面。

defer 和 async 之间的不同是他们开始执行脚本的时机的不同。

defer 比 async 要先引入浏览器。它的执行在解析完全完成之后才开始，它处在DOMContentLoaded事件之前。 它保证脚本会按照它在 HTML 中出现的顺序执行，并且不会阻塞解析。

async 脚本在它们完成下载完成后的第一时间执行，它处在 window 的load 事件之前。 这意味着有可能（并且很有可能）设置了 async 的脚本不会按照它们在 HTML 中出现的顺序执行。这也意味着他们可能会中断 DOM 的构建。

无论它们在何处被指定，设置async 的脚本的加载有着较低的优先级。他们通常在所有其他脚本加载之后才加载，而不阻塞 DOM 构建。然而，如果一个指定async 的脚本很快就完成了下载，那么它的执行会阻塞 DOM 构建以及所有在之后才完成下载的同步脚。


> 注: async 和 defer 属性只对外部脚本起作用，如果没有 src 属性它们会被忽略。

## preload
对于那些重要的资源，现在可以使用 preload 来告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级。

``` html
<link rel="preload" href="very_important.js" as="script">
```

as 属性告诉浏览器要下载的是什么。一些可能的值是：

* script
* style
* image
* font
* audio
* video

要预加载字体你还必须设置 crossorigin 属性，即使字体在同一个域名下：

``` html
<link rel="preload" href="font.woff" as="font" crossorigin>
```

## prefetch
prefetch 告诉浏览器用户将来可能在其他页面（非本页面）可能使用到的资源，那么浏览器会在空闲时，就去预先加载这些资源放在 http 缓存内。

prefetch 包括资源预加载、DNS 预解析、http 预连接和页面预渲染。

``` html
资源预加载：<link rel="prefetch" href="test.css">
DNS预解析：<link rel="dns-prefetch" href="//haitao.nos.netease.com">
http预连接：<link rel="prefetch" href="//www.kaola.com"> 将建立对该域名的TCP链接
页面预渲染：<link rel="prerender" href="//m.kaola.com"> 将会预先加载链接文档的所有资源
```

## reflow 和 repaint
reflow 为回流，指的是页面再次构建 render 树。每个页面至少发生一次回流，就是第一次加载页面的时候。

reflow 为回流，指的是页面再次构建render树。每个页面至少发生一次回流，就是第一次加载页面的时候

> 注意：重排必将引起重绘，而重绘不一定会引起重排，重排比重绘对性能的开销更大。重排不能避免，只能尽量减小。

### 浏览器解析过程
* 解析 html 生成 dom 树；
* 解析 css；
* 把 css 应用于 dom 树，生成 render 树(这里记录这每一个节点和它的样式和所在的位置);
* 把 render 树渲染到页面。

### 什么时候发生重排
* 元素的添加或删除；
* 元素位置的改变；
* 元素大小尺寸的改变；
* 内容发生变化，如 input 输入文字时；
* 窗口 resize；
* 触发伪类，如:hover；
* 操作 className；
* 读取元素的 offsetTop 系列、offsetWidth 系列、scrollWidth 系列、clientWidth 系列、getComputedStyle 系列。

### 为了减少重排，在做页面渲染优化时应该从以下方面着手：
* 在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排；
* 避免多次操作 DOM 的 style，应该换成 class,对于动态样式，一次性使用 cssText；
* 频繁插入 DOM 元素时，可先用 documentFragment 来做缓存，创建一个 documentFragment，将新生成的 DOM 都插入 documentFragment 中，最后一次性将 documentFragment 插入文档，只触发一次重排；
* 对于频繁更改大小位置的元素，可使用 display: none 使其“离线”,操作完成后再 display: block ，这样就只触发了2次重排；
* 避免使用 JS 动画，用 CSS 动画替换；
* 合理缓存 DOM 对象，减少 DOM 查询；
* 对元素使用 position: absolute 或者 position: fixed，使其脱离文档流，它的变化不会影响其他元素；
* 使用 CSS3 的 contain，控制页面的重绘与重排；
* 尽量使用 CSS3 的 translate、scale 属性代替 top、left 和 height、width，避免大量的重排计算；
* 滚动或 resize 时使用节流函数，并减少 DOM 操作；
* 开启 GPU 加速 transform:translateZ(0),GPU 加速会创建一个新的图层，与其他图层互不影响；
* 选择 Canvas 或 requestAnimationFrame 等更高效的动画实现方式，尽量避免使用 setTimeout、setInterval 等方式来直接处理连续动画。