#移动端布局方案
默认「body」的宽度取自「HTML」，而「HTML」的宽度取自「viewport」，「viewport」的宽度正好等于「浏览器」窗口的宽度。

## 视觉稿
设计常用尺寸：750 x 1334 / 640 x 1134，包含了手机顶部信号栏的高度。视觉稿的规范往往会遵循以下两点：

* 首先，选取一款手机的屏幕宽高作为基准(以前是iphone4的320×480，现在更多的是iphone6的375×667)。

* 对于retina屏幕(如: dpr=2)，为了达到高清效果，视觉稿的画布大小会是基准的2倍，也就是说像素点个数是原来的4倍（对iphone6而言：原先的375×667，就会变成750×1334）。

## 概念
### 物理像素(physical pixel)

一个物理像素是显示器(手机屏幕)上最小的物理显示单元，我们操作 css 像素，然后由物理像素进行表达，在 Retina 屏出来以前，css 像素的数量 === 物理像素。

### 设备独立像素(density-independent pixel)

设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。也就是说可以使用 css 操作到的像素。

### 设备像素比(device pixel ratio )

设备像素比(简称 dpr)定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到：

``` bash
设备像素比 = 物理像素 / 设备独立像素
```
	
在 javascript 中，可以通过 `window.devicePixelRatio` 获取到当前设备的 dpr。

在 css 中，可以通过 `-webkit-device-pixel-ratio` ， `-webkit-min-device-pixel-ratio` 和 `-webkit-max-device-pixel-ratio` 进行媒体查询，对不同 dpr 的设备，做一些样式适配(这里只针对 webkit 内核的浏览器和 webview )。

### 屏幕分辨率
屏幕上显示的像素个数，注意的是屏幕分辨率跟屏幕大小不一定成正比的。

### 像素密度（ppi）
每英寸屏幕的像素数，这个属性跟屏幕分辨率是有直接关系的，一般来说，高像素密度的屏，屏幕分辨率也越大。

所以，以 iphone6 为例说明以上概念：

* 设备宽高为375×667，可以理解为设备独立像素(或css像素)。
* dpr为2，根据上面的计算公式，其物理像素就应该×2，为750×1334。
![](http://www.ui3g.com/upload/2016_06/6360236503562082724114698.gif)

## 视口
在桌面端，视口指的是浏览器的可视区域；而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。

### 视口单位主要包括以下4个：

* vw : 1vw 等于视口宽度的1%
* vh : 1vh 等于视口高度的1%
* vmin : 选取 vw 和 vh 中最小的那个
* vmax : 选取 vw 和 vh 中最大的那个

例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。

### 兼容性
在移动端 iOS 8 以上以及 Android 4.4 以上获得支持，并且在微信 x5 内核中也得到完美的全面支持。

![视口单位兼容性](https://misc.aotu.io/Tingglelaoo/caniuse_viewport.png)

对于移动端开发来说，最为重要的一点是如何适配页面，实现多终端的兼容，不同的适配方式各有千秋，也各有缺点。

采用rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得 CSS 与 JS 耦合了在一起。

## 布局方案
### 一、仅使用vw作为CSS单位
1、对于设计稿的尺寸转换为 vw 单位，可以使用 Sass 函数编译：

``` scss
//iPhone 6尺寸作为设计稿基准
$vm_base: 375; 
@function vw($px) {
    @return ($px / 375) * 100vw;
}
```

2、无论是文本还是布局高宽、间距等都使用 vw 作为 CSS 单位：

``` scss
.mod_nav {
    background-color: #fff;
    &_list {
        display: flex;
        padding: vm(15) vm(10) vm(10); // 内间距
        &_item {
            flex: 1;
            text-align: center;
            font-size: vm(10); // 字体大小
            &_logo {
                display: block;
                margin: 0 auto;
                width: vm(40); // 宽度
                height: vm(40); // 高度
                img {
                    display: block;
                    margin: 0 auto;
                    max-width: 100%;
                }
            }
            &_name {
                margin-top: vm(2);
            }
        }
    }
}
```

3、对于需要保持高宽比的图，应改用 padding-top 实现：

``` scss
.mod_banner {
    position: relative;
    // 计算公式：padding-top = (Image Height / Image Width) * 100%
    padding-top: percentage(100/700); // padding-top值为百分比时，取值是是相对于宽度的。
    height: 0;
    overflow: hidden;
    img {
        width: 100%;
        height: auto;
        position: absolute;
        left: 0;
        top: 0; 
    }
}
```

> 缺点：这样的页面虽然看起来适配得很好，但是你会发现由于它是利用视口单位实现的布局，依赖于视口大小而自动缩放，无论视口过大还是过小，它也随着视口过大或者过小，失去了最大最小宽度的限制。

### 二、搭配 vw 和 rem，布局更优化
rem 弹性布局的核心在于动态改变根元素大小，那么我们可以通过以下方式就能够实现对布局宽度的最大最小限制。

* 给根元素大小设置随着视口变化而变化的 vw 单位，这样就可以实现动态改变其大小。
* 限制根元素字体大小的最大最小值，配合 body 加上最大宽度和最小宽度。

``` scss
// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推
$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值
@function rem($px) {
     @return ($px / $vm_fontsize ) * 1rem;
}
// 根元素大小使用 vw 单位
$vm_design: 750;
html {
    font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; 
    // 同时，通过Media Queries 限制根元素最大最小值
    @media screen and (max-width: 320px) {
        font-size: 64px;
    }
    @media screen and (min-width: 540px) {
        font-size: 108px;
    }
}
// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小
body {
    max-width: 540px;
    min-width: 320px;
}
```

### 三、lib-flexible 弹性布局方案
#### 引用
``` js
<script src="http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js"></script>

//或者复制 https://github.com/amfe/lib-flexible 项目里的 flexible.js 在本地新建就可以了 
```

尽可能早的在所有资源加载之前引入 `flexible.js` 。因为执行这个 js 后，会在 html 标签上增加一个 data-dpr 属性，以及 font-size 样式。之后页面中的元素，都可以用 rem 单位来设置。html 上的 font-size 就是 rem 的基准像素。

> 注意：引入该文件后，不需要再在头部设置 `<meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no" />` 了。

#### 把视觉稿中的 px 转换成 rem
因为在 flexible.js 中是把视觉稿分成 100 份来看待（为了以后兼容 vh，vw 单位）。每一份被称为一个单位 a。同时，1rem 单位认定为 10a。

``` css
1a = 视觉稿 / 100
1rem = 10a
```

因此，对于视觉稿上的元素的尺寸换算公式为：

```
	原始设计图 px 值 / 1rem 基准 px 值大小
```

而 1rem 基准 px 值大小的公式是：

```
原始设计图宽度 px 值 / 10
```

例如：以 750 * 1334 的视觉稿为例，1rem 基准 px 值大小就是 75px ，设计稿上的 240px * 120px 的元素，最后转换为 3.2rem * 1.6rem 的大小。

#### 字体不使用 rem 的方法
字体的大小不推荐用 rem 作为单位。所以对于字体的设置，仍旧使用 px 作为单位，并配合用 data-dpr 属性来区分不同 dpr 下的的大小。

``` css
div {
  width: 1rem; 
  height: 0.4rem;
  font-size: 12px; // 默认写上dpr为1的fontSize }

[data-dpr="2"] div {
  font-size: 24px;
}

[data-dpr="3"] div {
  font-size: 36px;
}
```

#### 解决图片在 retina 屏下的可行方案
* 在 devicePixelRatio <= 2 时，图片统一使用 750 设计稿的切图；
* 在 devicePixelRatio > 2 时，图片统一使用 750 * 1.5 = 1125， 也就是所谓的 @3x 设计稿的切图。

``` css
.img-bg {
  background-image:url("img/@2x/logo.png?v=@@version");  
}

[data-dpr="3"] .img-bg {
  background-image:url("img/@3x/logo.png?v=@@version");  
}
```

### 设置 rem 基准值的方法
``` css
html {font-size: 75px!important;}
```

## 判断横竖屏的实现
### 内联样式
``` css
@media screen and (orientation:portrait) {
    //竖屏
}
@media screen and (orientation:landscape) {
    //横屏
}
```

### 外联样式
``` html
<!-- 竖屏 -->
<link rel="stylesheet" media="all and (orientation:portrait)" href="..." />
<!-- 横屏 -->
<link rel="stylesheet" media="all and (orientation:landscape)" href="..." />
```

### window.matchMedia
window.matchMedia() 方法接受一个 Media Queries 语句的字符串作为参数，返回一个 MediaQueryList 对象。该对象有 media 和 matches 两个属性：

* media：返回所查询的 Media Queries 语句字符串
* matches：返回一个布尔值，表示当前环境是否匹配查询语句

同时，它还包含了两个方法，用来监听事件：

* addListener(callback)：绑定回调 callback 函数
* removeListener(callback)：注销回调 callback 函数

``` js
var mql = window.matchMedia("(orientation: portrait)");
function onMatchMeidaChange(mql){
    if(mql.matches) {
        // 竖屏
    }else {
        // 横屏
    }
}
onMatchMeidaChange(mql);
mql.addListener(onMatchMeidaChange);
```

### window.innerHeight/window.innerWidth
还有一种最为常见的方法是通过比较页面的宽高，当页面的高大于等于宽时则认为是竖屏，反之则为横屏。

``` js
function detectOrient(){
    if(window.innerHeight >= window.innerWidth) {
        // 竖屏
    }else {
        // 横屏 
    }
}
detectOrient();
window.addEventListener('resize',detectOrient);
```

### window.orientation
在 iOS 平台以及大部分 Android 手机都有支持 window.orientation 这个属性，它返回一个与默认屏幕方向偏离的角度值：

* 0：代表此时是默认屏幕方向
* 90：代表顺时针偏离默认屏幕方向90度
* -90：代表逆时针偏离默认屏幕方向90度
* 180：代表偏离默认屏幕方向180度

``` js
switch(window.orientation) {
    case 0:
        displayStr += "Portrait";
        break;
    case -90:
        displayStr += "Landscape (right, screen turned clockwise)";
        break;
    case 90:
        displayStr += "Landscape (left, screen turned counterclockwise)";
        break;
    case 180:
        displayStr += "Portrait (upside-down portrait)";
        break;
}
```

### 最优方案
``` html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" />
```

``` js
// 判断横竖屏
var utils = {
    debounce: function(func,delay){
        var timer = null;
        return function(){
            var context = this,
                args = arguments;
            clearTimeout(timer);
            timer = setTimeout(function(){
                func.apply(context,args);
            },delay);
        }
    }
}

var detectRes = document.getElementById('J_detectRes');
var detectData = document.getElementById('J_detectData');

function detectOrient() {
    var storage = localStorage; // 不一定要使用localStorage，其他存储数据的手段都可以
    var data = storage.getItem('J-recordOrientX');
    var cw = document.documentElement.clientWidth;

    var _Width = 0,
        _Height = 0;
    if(!data) {
        sw = window.screen.width;
        sh = window.screen.height;
        // 2.在某些机型（如华为P9）下出现 srceen.width/height 值交换，所以进行大小值比较判断
        _Width = sw < sh ? sw : sh;
        _Height = sw >= sh ? sw : sh;
        storage.setItem('J-recordOrientX',_Width + ',' + _Height);
    }else {
        var str = data.split(',');
        _Width = str[0];
        _Height = str[1];
    }

    if(cw == _Width) {
        // 竖屏
        return;
    }
    if(cw == _Height){
        // 横屏
        return;
    }

}

// 3.函数去抖处理
window.onresize = utils.debounce(detectOrient,300);
detectOrient();
```

## 1物理像素线
iOS设备上，由于retina屏的原因，1px 的 border 会显示成两个物理像素，所以看起来会感觉很粗，这是一个移动端开发常见的问题。解决方案有很多，但都有自己的优缺点。

### 方案一：0.5px border

从iOS 8开始，iOS 浏览器支持 0.5px 的 border，但是在 Android 上是不支持的，0.5px 会被认为是 0px，所以这种方法，兼容性是很差的。

### 方案二：transform
也就是普通屏幕下 1px ，高清屏幕下 0.5px 的情况，采用 transform 属性 scale 实现：

``` scss
.mod_grid {
    position: relative;
    &::after {
        // 实现1物理像素的下边框线
        content: '';
        position: absolute;
        z-index: 1;
        pointer-events: none;
        background-color: #ddd;
        height: 1px;
        left: 0;
        right: 0;
        top: 0;
        @media only screen and (-webkit-min-device-pixel-ratio: 2) {
            -webkit-transform: scaleY(0.5);
            -webkit-transform-origin: 50% 0%;
        }
    }
    ...
}
```

### 方案三：背景渐变

CSS3 有了渐变背景，可以通过渐变背景实现 1px 的 border，实现原理是设置 1px 的渐变背景，50% 有颜色，50% 是透明的。但是这种方法没有办法实现圆角。

``` scss
@mixin commonStyle() {
  background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%;
  background-repeat: no-repeat;
  background-position: top, right top,  bottom, left top;
}


@mixin border($border-color) {
  @include commonStyle();
  background-image:linear-gradient(180deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(270deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(0deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(90deg, $border-color, $border-color 50%, transparent 50%);
}
```

## 解决截断非直接输入
``` js
var inputLock = false;

// 限制输入特殊字符
function do(inputElement) {
    var regex = /[^1-9a-zA-Z]/g;
    inputElement.value = inputElement.value.replace(regex, '');
}

inputElement.addEventListener('compositionstart', function() {
  inputLock = true;
});


inputElement.addEventListener('compositionend', function(event) {
  inputLock = false;
  do(event.target);
})

// 在 Web 开发中，经常要对表单元素的输入进行限制，比如说不允许输入特殊字符，标点。通常我们会监听 input 事件
inputElement.addEventListener('input', function(event) {
  if (!inputLock) {
    do(event.target);
    event.returnValue = false;
  }
});
```

## 插件
[Swiper.js](http://www.swiper.com.cn) ：是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端。

[Animate.css](https://daneden.github.io/animate.css/) ：是纯 CSS 编写而成的动画库，包含多种常见的 CSS 动画。

[flexible.js](https://github.com/amfe/lib-flexible)：可伸缩布局方案。

[AlloyTouch](https://github.com/AlloyTeam/AlloyTouch)：丝般顺滑的触摸运动方案

## 相关头部设置
### 添加到主屏后的标题（IOS）

``` html
<meta name="apple-mobile-web-app-title" content="标题"> 
```

### 添加到主屏后的APP图标

``` html
<link href="short_cut_114x114.png" rel="apple-touch-icon-precomposed">
```

### 启用 WebApp 全屏模式（IOS）

当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果）

``` html
<meta name="apple-mobile-web-app-capable" content="yes" /> 
<meta name="apple-touch-fullscreen" content="yes" /> 
```

### 百度禁止转码

通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：

``` html
<meta http-equiv="Cache-Control" content="no-siteapp" />
```

### 关闭电话号码的自动识别：

``` html
<meta name="format-detection" content="telephone=no" />

<!-- 开启电话功能 -->
<a href="tel:123456">123456</a>

<!-- 开启短信功能： -->
<a href="sms:123456">123456</a> 
```

### 关闭邮箱的自动识别：

``` html
<meta content="email=no" name="format-detection" /> 

<!-- 开启长按邮箱地址弹出邮件发送的功能：-->
<a mailto:faychou@gmail.com">dooyoe@gmail.com</a> 
```